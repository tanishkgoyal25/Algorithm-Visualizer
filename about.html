<!DOCTYPE html>
<html>

<head>
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Anta&display=swap" rel="stylesheet">
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>About</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f0f0f0;
            background-image: url(mainbg.jpg)
        }

        .container {
            width: 80%;
            margin: 0 auto;
        }

        .header {
            background-color: #333;
            color: #fff;
            padding: 10px 0;
            text-align: center;
        }

        .content {
            background-color: lightgray;
            padding: 50px;
            margin-top: 25px;
            font-family: "Anta", sans-serif;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>Learn about Algorithms!</h1>
        </div>
        <div class="content">
            <h2>Sorting Algorithm</h2>
            <p>Sorting algorithms are used to sort a data structure according to a specific order relationship, such as numerical order or lexicographical order.</p>
            <p>
                This operation is one of the most important and widespread in computer science.
                For a long time, new methods have been developed to make this procedure faster and faster.
            </p>
            <p>
            There are currently hundreds of different sorting algorithms, each with its own specific characteristics.
            They are classified according to two metrics: space complexity and time complexity.<br><br>
            Those two kinds of complexity are represented with <a href="https://www.programiz.com/dsa/asymptotic-notations#:~:text=Asymptotic%20notations%20are%20the%20mathematical,linear%20i.e.%20the%20best%20case." target="_blank">asymptotic notations</a>, mainly with the symbols O, <span class="symbol">Θ</span>, <span class="symbol">Ω</span>, representing
            respectively the upper bound, the tight bound, and the lower bound of the algorithm's complexity, specifying in brackets an expression in terms of
            <code><var>n</var></code>, the number of the elements of the data structure.<br><br>
            Most of them fall into two categories:
            </p>
            <ul>
                <li>Logarithmic<br>
                    The complexity is proportional to the binary logarithm (i.e to the base 2) of <code><var>n</var></code>.<br>
                    An example of a logarithmic sorting algorithm is Quick sort, with space and time complexity O<code>(n × log n)</code>.<br><br>
                </li>
                <li>Quadratic<br>
                    The complexity is proportional to the square of <code><var>n</var></code>.<br>
                    An example of a quadratic sorting algorithm is Bubble sort, with a time complexity of O<code>(n<sup>2</sup>)</code>.<br>
                </li>
            </ul>
            <p>
                Space and time complexity can also be further subdivided into 3 different cases: best case, average case and worst case.
            </p>
            <p>
                Sorting algorithms can be difficult to understand and it's easy to get confused.
                We believe visualizing sorting algorithms can be a great way to better understand their functioning while having fun!
            </p>

            <center><h1>Logarithmic</h1></center>
            <h2>Quick Sort</h2>
            <div>DESCRIPTION</div>
            
            <p>
            Quick Sort is a sorting algorithm based on splitting the data structure in smaller partitions and sort them recursively until the data structure is sorted.
            </p>
            <p>
            This division in partitions is done based on an element, called pivot:
            all the elements bigger than the pivot get placed on the right side of the structure, the smaller ones to the left, creating two partitions.
            Next, this procedure gets applied recursively to the two partitions and so on.
            </p>
            <p>
            This partition technique based on the pivot is called <a href="https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm" target="_blank">Divide and conquer</a>.
            It's a performant strategy also used by other sorting algorithms, such as Merge Sort</a>.
            </p>
            <h2>Merge Sort</h2>
            <div>DESCRIPTION</div>
            
            <p>
            Merge Sort is a sorting algorithm based on the Divide et Impera technique, like Quick Sort</a>.
            It can be implemented iteratively or recursively, using the Top-Down and Bottom-Up algorithms respectively.
            We represented the first one.
            </p>
            <p>
            The algorithm divides the data structure recursively until the subsequences contain only one element.
            At this point, the subsequences get merged and ordered sequentially.
            To do so, the algorithm progressively builds the sorted sublist by adding each time the minimum element of the next two unsorted subsequences until there is only one sublist remaining.
            This will be the sorted data structure.
            </p>
            <h2>Heap Sort</h2>
            <div>DESCRIPTION</div>
            <p>
                Merge Sort is a sorting algorithm based on the Divide et Impera technique, like Quick Sort</a>.
                It can be implemented iteratively or recursively, using the Top-Down and Bottom-Up algorithms respectively.
                We represented the first one.
                </p>
                <p>
                The algorithm divides the data structure recursively until the subsequences contain only one element.
                At this point, the subsequences get merged and ordered sequentially.
                To do so, the algorithm progressively builds the sorted sublist by adding each time the minimum element of the next two unsorted subsequences until there is only one sublist remaining.
                This will be the sorted data structure.
            </p>
            <center><h1>Quadratic</h1></center>
            <h2>Bubble Sort</h2>
            <div>DESCRIPTION</div>
            <p>
                Bubble Sort is an iterative sorting algorithm that imitates the movement of bubbles in sparkling water.
                The bubbles represents the elements of the data structure.
                </p>
                <p>
                The bigger bubbles reach the top faster than smaller bubbles, and this algorithm works in the same way. It iterates through the data structure and for each cycle compares the current element with the next one,
                swapping them if they are in the wrong order.
                </p>
                <p>
                It's a simple algorithm to implement, but not much efficient: on average, quadratic sorting algorithms with the same time complexity such as Selection Sort or Insertion Sort perform better.
                It has several variants to improve its performances, such as Shaker Sort, Odd Even Sort and Comb Sort.
            </p>
            <h2>Selection Sort</h2>
            <div>DESCRIPTION</div>
            <p>
                Selection Sort is an iterative and in-place sorting algorithm that divides the data structure in two sublists: the ordered one, and the unordered one.
                The algorithm loops for all the elements of the data structure and for every cycle picks the smallest element of the unordered sublist and adds it to the sorted sublist, progressively filling it.
                </p>
                <p>
                It's a really simple and intuitive algorithm that does not require additional memory, but it's not really efficient on big data structures due to its quadratic time complexity.
                </p>
                <p>
                This algorithm has been upgraded and enhanced in several variants such as Heap Sort</a>.
            </p>
            <h2>Insertion Sort</h2>
            <div>DESCRIPTION</div>
            <p>
                Insertion sort is a simple sorting algorithm that builds the final sorted array one item at a time.
                It's less performant than advanced sorting algorithms, but it can still have some advantages: it's really easy to implement and it's efficient on small data structures almost sorted.
                </p>
                <p>
                The algorithm divides the data structure in two sublists: a sorted one, and one still to sort. Initially, the sorted sublist is made up of just one element and it gets progressively filled.
                For every iteration, the algorithm picks an element on the unsorted sublist and inserts it at the right place in the sorted sublist.
                It's available in several variants such as Gnome Sort</a>.
            </p>
        </div>
    </div>
</body>

</html>